// Preprocessor directives
//#n Wyam.Yaml
//#n Wyam.Razor
//#n Wyam.Markdown
//#n Wyam.Html
//#n Wyam.CodeAnalysis

#a **/*
/*
 * Hack to have intellisense in VS Code when debugging from IDE.
*/

#n System.Xml.ReaderWriter
#n System.Xml.XDocument

#recipe Docs

// Body code
// Normalize the culture for the examples so they produce the same output regardless of system culture
System.Globalization.CultureInfo.DefaultThreadCurrentCulture
    = System.Globalization.CultureInfo.CreateSpecificCulture("en-US");

ContentStreamFactory = new MemoryContentStreamFactory();

if(!Settings.ContainsKey(NAntKeys.Release))
{
    Settings[NAntKeys.Release] = "latest";
}

if(!Settings.ContainsKey(Keys.Host))
{
    Settings[Keys.Host] = string.Empty;
}
if(!Settings.ContainsKey(Keys.LinksUseHttps))
{
    Settings[Keys.LinksUseHttps] = false;
}
Settings[Keys.LinkRoot] = "/";
Settings[DocsKeys.Title] = "NAnt2";
Settings[DocsKeys.Logo] = "/assets/img/logo-dark.png";
//Settings[DocsKeys.ProjectFiles] = "../../src/**/{!.vscode,!bin,!obj,!packages,!*.Tests, !NDoc.*.NAnt,}/**/*.csproj";//
Settings[DocsKeys.ProjectFiles] = "../../src/{NAnt.Core,NAnt.DotNet}/*.csproj";
Settings[DocsKeys.IncludeDateInPostPath] = true;
Settings[DocsKeys.BlogAtomPath] = "blog/feed/atom/index.xml";
Settings[DocsKeys.BlogRssPath] = "blog/feed/rss/index.xml";
Settings[DocsKeys.BlogRdfPath] = null;
Settings[DocsKeys.CaseInsensitiveAuthors] = "true";
Settings[DocsKeys.CaseInsensitiveCategories] = "true";
Settings[DocsKeys.CaseInsensitiveTags] = "true";
Settings[DocsKeys.IgnoreFolders] = "_reference";
Settings[DocsKeys.ImplicitInheritDoc] = true;

/// <value>When true pipelines Docs.RenderApi, Docs.ApiIndex and Docs.ApiSearchIndex are not executed.</value>
bool noApi = true;
/// <value>
/// When true pipelines Docs.BlogPosts, Docs.BlogIndexes, Docs.BlogCategories, Docs.BlogTags, Docs.BlogAuthors, 
/// Docs.BlogArchives, Docs.BlogYearlyArchives, Docs.BlogFeed, Docs.RenderBlogPosts are not executed.
/// </value>
bool noBlog = false;
/// <value>When true pipelines Docs.Pages, Docs.RenderPages, Docs.Redirects are not executed.</value>
bool noPages = false;

/**********************************************************************************************
 *                         NAnt customizations
 **********************************************************************************************/
 /// <summary>
 /// Meta-keys specific for NAnt.
 /// </summary>
 public static class NAntKeys
{
     /// <summary>
    /// The release version to generate reference documentation.
    /// </summary>
    /// <type><see cref="string"/></type>
    public const string Release = nameof(Release);

    /// <summary>
    /// The assembly where the reference is located.
    /// </summary>
    public const string NAntAssembly = nameof(NAntAssembly);

    /// <summary>
    /// The namespace where the reference is located.
    /// </summary>
    public const string NAntNamespace = nameof(NAntNamespace);

    /// <summary>
    /// The page title for the NAnt reference.
    /// </summary>
    public const string NAntTitle = nameof(NAntTitle);

    /// <summary>
    /// The display name for the NAnt reference.
    /// </summary>
    public const string NAntDisplayName = nameof(NAntDisplayName);

    /// <summary>
    /// The reference type: task, function, type, filter, function set.
    /// </summary>
    public const string NAntRefType = nameof(NAntRefType);

    /// <summary>
    /// The NAnt reference is obsolete.
    /// </summary>
    public const string NAntObsolete = nameof(NAntObsolete);
};

/// <summary>
/// NAnt reference types (task, type, function, filter, function set, parameters, nested elements, other elements and public enums).
/// </summary>
public enum NAntRefType{
    None,
    Tasks,
    Types,
    Functions,
    Filters,
    FunctionSets,
    Parameters,
    NestedElements,
    Elements,
    Enums
};

public class SlimMeta
{
    public string SourceString { get; set; }
    public string Id { get; set; }
    public string Accessibility { get; set; }
    public string CommentId { get; set; }
    public string CommentXml { get; set; }
    public object ConstantValue { get; set; }
    public string DisplayName { get; set; }
    public string Example { get; set; }
    public string FullName { get; set; }
    public bool HasConstantValue { get; set; }
    public bool IsAbstract { get; set; }
    public bool IsOverride { get; set; }
    public bool IsResult { get; set; }
    public bool IsStatic { get; set; }
    public bool IsVirtual { get; set; }
    public string Kind { get; set; }
    public string Name { get; set; }
    public string QualifiedName { get; set; }
    public string RelativeFilePath { get; set; }
    public string RelativeFilePathBase { get; set; }
    public string Remarks { get; set; }
    public string Returns { get; set; }
    public string SpecificKind { get; set; }
    public string Summary { get; set; }
    //public object Symbol { get; set; }
    public string SymbolId { get; set; }
    public string Syntax { get; set; }
    public string Value { get; set; }
    public string WritePath { get; set; }

    protected SlimMeta(){ }

    public SlimMeta(IDocument meta)
    {
        if(meta == null) return;

        SourceString = meta.SourceString(); 
        Id = meta.Id;
        Accessibility = meta.Get<string>(CodeAnalysisKeys.Accessibility);
        CommentId = meta.Get<string>(CodeAnalysisKeys.CommentId);
        CommentXml = meta.Get<string>(CodeAnalysisKeys.CommentXml);
        ConstantValue = meta.Get(CodeAnalysisKeys.ConstantValue);
        DisplayName = meta.Get<string>(CodeAnalysisKeys.DisplayName);
        Example = meta.Get<string>(CodeAnalysisKeys.Example);
        FullName = meta.Get<string>(CodeAnalysisKeys.FullName);
        HasConstantValue = meta.Get<bool>(CodeAnalysisKeys.HasConstantValue);
        IsAbstract = meta.Get<bool>(CodeAnalysisKeys.IsAbstract);
        IsOverride = meta.Get<bool>(CodeAnalysisKeys.IsOverride);
        IsResult = meta.Get<bool>(CodeAnalysisKeys.IsResult);
        IsStatic = meta.Get<bool>(CodeAnalysisKeys.IsStatic);
        IsVirtual = meta.Get<bool>(CodeAnalysisKeys.IsVirtual);
        Kind = meta.Get<string>(CodeAnalysisKeys.Kind);
        Name = meta.Get<string>(CodeAnalysisKeys.Name);
        QualifiedName = meta.Get<string>(CodeAnalysisKeys.QualifiedName);
        RelativeFilePath = meta.Get<string>(Keys.RelativeFilePath);
        RelativeFilePathBase = meta.Get<string>(Keys.RelativeFilePathBase);
        Remarks = meta.Get<string>(CodeAnalysisKeys.Remarks);
        Returns = meta.Get<string>(CodeAnalysisKeys.Returns);
        SpecificKind = meta.Get<string>(CodeAnalysisKeys.SpecificKind);
        Summary = meta.Get<string>(CodeAnalysisKeys.Summary);
        //Symbol = meta.Get(CodeAnalysisKeys.Symbol);
        SymbolId = meta.Get<string>(CodeAnalysisKeys.SymbolId);
        Syntax = meta.Get<string>(CodeAnalysisKeys.Syntax);
        Value = meta.Get<string>(CodeAnalysisKeys.Value);
        WritePath = meta.Get<string>(Keys.WritePath);
    }
};
public class SlimDoc : SlimMeta
{
    public List<SlimMeta> AllInterfaces { get; set; }
    public string AttributeData { get; set; }
    public List<SlimMeta> Attributes { get; set; }
    public List<SlimMeta> BaseTypes { get; set; }
    public List<SlimMeta> Constructors { get; set; }
    public SlimMeta ContainingAssembly { get; set; }
    public SlimMeta ContainingNamespace { get; set; }
    public SlimMeta ContainingType { get; set; }
    public SlimMeta DeclaringType { get; set; }
    public List<SlimMeta> DerivedTypes { get; set; }
    public List<SlimMeta> ImplementingTypes { get; set; }
    public List<SlimMeta> MemberNamespaces { get; set; }
    public List<SlimMeta> Members { get; set; }
    public List<SlimMeta> MemberTypes { get; set; }
    public List<SlimMeta> Operators { get; set; }
    public SlimMeta OverriddenMethod { get; set; }
    public List<SlimMeta> Parameters { get; set; }

    protected SlimDoc(){ }

    public SlimDoc(IDocument iDoc)
        : base(iDoc)
    {
        if(iDoc == null) return;

        AllInterfaces = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.AllInterfaces)?.Select(x => new SlimMeta(x)).ToList();
        AttributeData = AttrToString(iDoc.Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData));
        Attributes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Attributes)?.Select(x => new SlimMeta(x)).ToList();
        BaseTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.BaseTypes)?.Select(x => new SlimMeta(x)).ToList();
        Constructors = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Constructors)?.Select(x => new SlimMeta(x)).ToList();
        ContainingAssembly = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.ContainingAssembly));
        ContainingNamespace = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace));
        ContainingType = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.ContainingType));
        DeclaringType = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.DeclaringType));
        DerivedTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.DerivedTypes)?.Select(x => new SlimMeta(x)).ToList();
        ImplementingTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.ImplementingTypes)?.Select(x => new SlimMeta(x)).ToList();
        MemberNamespaces = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.MemberNamespaces)?.Select(x => new SlimMeta(x)).ToList();
        Members = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Members)?.Select(x => new SlimMeta(x)).ToList();
        MemberTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.MemberTypes)?.Select(x => new SlimMeta(x)).ToList();
        Operators = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Operators)?.Select(x => new SlimMeta(x)).ToList();
        OverriddenMethod = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.OverriddenMethod));
        Parameters = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Parameters)?.Select(x => new SlimMeta(x)).ToList();
    }

    private string AttrToString(Microsoft.CodeAnalysis.AttributeData attributeData)
    {
        if(attributeData == null) return string.Empty;

        string result = string.Format("[{0}({1})]",
                                      attributeData.AttributeClass?.Name,
                                      attributeData.ConstructorArguments == null
                                        ? string.Empty
                                        : string.Join(",", attributeData.ConstructorArguments.Select(x => x.Value.ToString()))
                        );
        return result;

    }
};

DocumentConfig DocToJson = (doc, ctx) => {
    Newtonsoft.Json.Serialization.DefaultContractResolver contractResolver = new Newtonsoft.Json.Serialization.DefaultContractResolver
    {
        NamingStrategy = new Newtonsoft.Json.Serialization.CamelCaseNamingStrategy
        {
            ProcessDictionaryKeys = false
        }
    };
    var settings = new Newtonsoft.Json.JsonSerializerSettings()
    { 
        ContractResolver = contractResolver,
        Formatting = Newtonsoft.Json.Formatting.Indented,
        PreserveReferencesHandling = Newtonsoft.Json.PreserveReferencesHandling.All,
        ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore

    };

    SlimDoc slimDoc = new SlimDoc(doc);
    string json = Newtonsoft.Json.JsonConvert.SerializeObject(slimDoc, settings);

    return json;
};

/// <summary>
/// If attribute is called <i>TaskNameAttribute</i> then it's a NAnt task attribute.
/// </summary>
Func<IDocument, bool> IsNAntTaskAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "TaskNameAttribute";
/// <summary>
/// If attribute is called <i>FunctionAttribute</i> then it's a NAnt function attribute.
/// </summary>
Func<IDocument, bool> IsNAntFunctionAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "FunctionAttribute";
/// <summary>
/// If attribute is called <i>FunctionSetAttribute</i> then it's a NAnt function set attribute.
/// </summary>
Func<IDocument, bool> IsNAntFunctionSetAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "FunctionSetAttribute";
/// <summary>
/// If attribute is called <i>ElementNameAttribute</i> it's a NAnt filter or type attribute.
/// </summary>
Func<IDocument, bool> IsNAntFilterOrTypeAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "ElementNameAttribute";
/// <summary>
/// If attribute is called <i>TaskAttributeAttribute</i> then it's a NAnt task parameter attribute.
/// </summary>
Func<IDocument, bool> IsNAntParameterAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "TaskAttributeAttribute";
/// <summary>
/// If attribute is called <i>BuildElementAttribute</i>, <i>BuildElementArrayAttribute</i> or <i>BuildElementCollectionAttribute</i> 
/// then it's a NAnt task nested element attribute.
/// </summary>
Func<IDocument, bool> IsNAntNestedElementAttribute = (attr) => 
{
    return attr.String(CodeAnalysisKeys.Name) == "BuildElementAttribute"
                || attr.String(CodeAnalysisKeys.Name) == "BuildElementArrayAttribute"
                || attr.String(CodeAnalysisKeys.Name) == "BuildElementCollectionAttribute";
};
/// <summary>
/// If attribute is called <i>Obsolete</i>.
/// </summary>
Func<IDocument, bool> IsNAntObsoleteAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "Obsolete";

/// <summary>
/// Returns true if the attribute is a NAnt task, function, filter, type, function set, parameter or nested element attribute.
/// </summary>
Func<IDocument, bool> IsNAntRefAttribute = (attr) => IsNAntTaskAttribute(attr) || IsNAntFilterOrTypeAttribute(attr) 
                                                            || IsNAntFunctionAttribute(attr) || IsNAntFunctionSetAttribute(attr) 
                                                            || IsNAntParameterAttribute(attr) || IsNAntNestedElementAttribute(attr);


/// <summary>
/// If document has an attribute called <i>TaskNameAttribute</i> then it's a NAnt task.
/// </summary>
Func<IDocument, bool> IsNAntTask = 
    (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class" 
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntTaskAttribute(attr));
/// <summary>
/// If document has an attribute called <i>FunctionAttribute</i> then it's a NAnt function.
/// </summary>
Func<IDocument, bool> IsNAntFunction = 
    (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Method"
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public" 
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFunctionAttribute(attr));
/// <summary>
/// If document has an attribute called <i>FunctionSetAttribute</i> then it's a NAnt function set.
/// </summary>
Func<IDocument, bool> IsNAntFunctionSet = 
    (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class" 
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFunctionSetAttribute(attr));
/// <summary>
/// If document has an attribute called <i>ElementNameAttribute</i> and derives from <i>Filter</i> then it's a NAnt filter.
/// </summary>
Func<IDocument, bool> IsNAntFilter = (doc) => 
{
    return doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class"
            && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
            && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
            && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFilterOrTypeAttribute(attr))
            && doc.DocumentList(CodeAnalysisKeys.BaseTypes) != null
            && doc.DocumentList(CodeAnalysisKeys.BaseTypes).Any(bt => bt.String(CodeAnalysisKeys.Name) == "Filter");
};
/// <summary>
/// If document has an attribute called <i>ElementNameAttribute</i> and is not derived from <i>Filter</i> then it's a NAnt type.
/// </summary>
Func<IDocument, bool> IsNAntType = (doc) => 
{
    return doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class"
            && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
            && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
            && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFilterOrTypeAttribute(attr))
            && (doc.DocumentList(CodeAnalysisKeys.BaseTypes) == null
                    || doc.DocumentList(CodeAnalysisKeys.BaseTypes).All(bt => bt.String(CodeAnalysisKeys.Name) != "Filter"));
};
/// <summary>
/// If document has an attribute called <i>TaskAttributeAttribute</i> then it's a NAnt task parameter.
/// </summary>
Func<IDocument, bool> IsNAntParameter = 
    (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Property" 
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntParameterAttribute(attr));
/// <summary>
/// If document has an attribute called <i>BuildElementAttribute</i>, <i>BuildElementArrayAttribute</i> or <i>BuildElementCollectionAttribute</i> 
/// then it's a NAnt task nested element.
/// </summary>
Func<IDocument, bool> IsNAntNestedElement =
    (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Property" 
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntNestedElementAttribute(attr));
/// <summary>
/// If document derives from <i>Element</i> then it's a NAnt element. 
/// </summary>
/// <returns></returns>
Func<IDocument, bool> IsNAntElement = (doc) =>
{
    bool isPublic = doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public";
    bool isClass = doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class";
    bool derivesFromElement = doc.DocumentList(CodeAnalysisKeys.BaseTypes) != null
                                && doc.DocumentList(CodeAnalysisKeys.BaseTypes).Any(bt => bt.String(CodeAnalysisKeys.QualifiedName) == "NAnt.Core.Element");
    bool notRef = doc.DocumentList(CodeAnalysisKeys.Attributes) == null 
                    || doc.DocumentList(CodeAnalysisKeys.Attributes).All(attr => !IsNAntRefAttribute(attr));

    // Wyam.Common.Tracing.Trace.Information(
    //     "[IsNAntElement({0})] returned {1} because it is a class: {4} derived from Element: {2} and does not have a NAnt ref attribute: {3}", 
    //     doc.String(CodeAnalysisKeys.QualifiedName),
    //     isClass && derivesFromElement && notRef,
    //     derivesFromElement,
    //     notRef,
    //     isClass);
    //Wyam.Common.Tracing.Trace.Verbose(DocToJson(doc, null).ToString());
    
    return isPublic && isClass && derivesFromElement && notRef;
};
/// <summary>
/// If document derives from <i>System.Enum</i> and it's public then it's a NAnt enum.
/// </summary>
/// <returns></returns>
Func<IDocument, bool> IsNAntEnum = (doc) =>
{
    return doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Enum"
            && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
            && doc.DocumentList(CodeAnalysisKeys.BaseTypes) != null
            && doc.DocumentList(CodeAnalysisKeys.BaseTypes).Any(bt => bt.String(CodeAnalysisKeys.QualifiedName) == "System.Enum")
            && doc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace).Get<string>(CodeAnalysisKeys.Name) != "Attributes"
            && doc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace).Get<string>(CodeAnalysisKeys.Name) != "Util";
};

/// <summary>
/// If document has an attribute called <i>Obsolete</i>.
/// </summary>
/// <returns></returns>
Func<IDocument, bool> IsNAntObsolete = 
    (doc) => doc.DocumentList(CodeAnalysisKeys.Attributes) == null 
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntObsoleteAttribute(attr));

/// <summary>
/// Returns true if the given <see cref="IDocument"/> is a NAnt task, function, filter or type.
/// </summary>
Func<IDocument, bool> IsNAntRef = (doc) => IsNAntTask(doc) || IsNAntType(doc) || IsNAntFunction(doc) || IsNAntFilter(doc);

/// <summary>
/// Gets the function set prefix and category.
/// </summary>
System.Func<IDocument, (string Prefix, string Category)> GetNAntFunctionSet = (doc) =>
{
    string prefix = string.Empty;
    string category = string.Empty;

    bool isNAntFunction = IsNAntFunction(doc);
    bool isNAntFunctionSet = IsNAntFunctionSet(doc);

    //document is not a function or function set
    if(!(isNAntFunction || isNAntFunctionSet))
    {
        return (Prefix: prefix, Category: category);
    }

    IDocument functionSetDoc = doc;
    if(isNAntFunction)
    {
       functionSetDoc = doc.Get<IDocument>(CodeAnalysisKeys.ContainingType);   
    }

    if(functionSetDoc == null) throw new NullReferenceException("A NAnt class decorated with FunctionSet attribute was not found");

    var attrDocs = functionSetDoc.DocumentList(CodeAnalysisKeys.Attributes);
    if(attrDocs != null)
    {
        Microsoft.CodeAnalysis.AttributeData attrib = attrDocs.First(attr => IsNAntFunctionSetAttribute(attr))
                                                        .Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData);
        prefix = attrib.ConstructorArguments[0].Value.ToString();
        category = attrib.ConstructorArguments[1].Value.ToString();
    }

    return (Prefix: prefix, Category: category);
};

DocumentConfig GetNantRefType = (doc, ctx) =>
{
    NAntRefType nantType = NAntRefType.None;

    if(IsNAntTask(doc))
    {
        nantType = NAntRefType.Tasks;
    }
    else if(IsNAntFilter(doc))
    {
        nantType = NAntRefType.Filters;
    }
    else if(IsNAntType(doc))
    {
        nantType = NAntRefType.Types;
    }
    else if(IsNAntFunction(doc))
    {
        nantType = NAntRefType.Functions;
    }
    else if(IsNAntFunctionSet(doc))
    {
        nantType = NAntRefType.FunctionSets;
    }
    else if(IsNAntParameter(doc))
    {
        nantType = NAntRefType.Parameters;
    }
    else if(IsNAntNestedElement(doc))
    {
        nantType = NAntRefType.NestedElements;
    }
    else if(IsNAntElement(doc))
    {
        nantType = NAntRefType.Elements;
    }
    else if(IsNAntEnum(doc))
    {
        nantType = NAntRefType.Enums;
    }

    // Wyam.Common.Tracing.Trace.Verbose("[GetNantRefType({0})] {0} is a NAntRefType.{1}", 
    //                                 doc.String(CodeAnalysisKeys.QualifiedName), 
    //                                 nantType);
    return nantType;
};

DocumentConfig GetNantRefTitle = (doc, ctx) =>
{
    string title = string.Empty;

    if(IsNAntElement(doc) || IsNAntEnum(doc))
    {
        title = doc.String(CodeAnalysisKeys.QualifiedName);
        // Wyam.Common.Tracing.Trace.Information("[GetNantRefTitle({0})] is a NAntElement and title was set to {1}", title, title);
    }
    else if(IsNAntRef(doc)|| IsNAntFunctionSet(doc) || IsNAntParameter(doc) || IsNAntNestedElement(doc))
    {
        var attrDocs = doc.DocumentList(CodeAnalysisKeys.Attributes);
        if(attrDocs != null)
        {
            Microsoft.CodeAnalysis.AttributeData attrib = attrDocs.First(attr => IsNAntRefAttribute(attr))
                                                            .Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData);
                            
            title = attrib?.ConstructorArguments[0].Value.ToString();   
            // Wyam.Common.Tracing.Trace.Information("[GetNantRefTitle({0})] is not a NAntElement and title was set to {1}", 
            //                                     doc.String(CodeAnalysisKeys.QualifiedName), 
            //                                     title);     
        }

        if(IsNAntFunction(doc))
        {
            //Wyam.Common.Tracing.Trace.Information("[GetNantRefTitle({0})] is a NAnt function", doc.String(CodeAnalysisKeys.QualifiedName));
            var functionSet = GetNAntFunctionSet(doc);
            title = $"{functionSet.Prefix}.{title}";

            // Wyam.Common.Tracing.Trace.Information("[GetNantRefTitle({0})] is not a NAntElement but is a NAnt function so title was set to {1}", 
            //                                     doc.String(CodeAnalysisKeys.QualifiedName), 
            //                                     title); 
        }
    }

    return title;
};

DocumentConfig GetNantRefDisplayName = (doc, ctx) =>
{
    string displayName = string.Empty;

    if(IsNAntElement(doc) || IsNAntEnum(doc))
    {
        displayName = doc.String(CodeAnalysisKeys.DisplayName);
        // Wyam.Common.Tracing.Trace.Information("[GetNantRefDisplayName({0})] is a NAntElement and displayName was set to {1}", 
        //                                       doc.String(CodeAnalysisKeys.QualifiedName), 
        //                                       displayName); 
    }
    else if(IsNAntRef(doc)|| IsNAntFunctionSet(doc) || IsNAntParameter(doc) || IsNAntNestedElement(doc))
    {
        var attrDocs = doc.DocumentList(CodeAnalysisKeys.Attributes);
        if(attrDocs != null)
        {
            Microsoft.CodeAnalysis.AttributeData attrib = attrDocs.First(attr => IsNAntRefAttribute(attr))
                                                            .Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData);
                                
            displayName = attrib?.ConstructorArguments[0].Value.ToString();
            // Wyam.Common.Tracing.Trace.Information("[GetNantRefDisplayName({0})] is not a NAntElement and displayName was set to {1}", 
            //                                       doc.String(CodeAnalysisKeys.QualifiedName), 
            //                                       displayName); 

            if(IsNAntFunction(doc))
            {
                var functionSet = GetNAntFunctionSet(doc);
                displayName = $"{functionSet.Prefix}::{displayName}";
                // Wyam.Common.Tracing.Trace.Information("[GetNantRefDisplayName({0})] is not a NAntElement but is a NantFunction so displayName was set to {1}", 
                //                                   doc.String(CodeAnalysisKeys.QualifiedName), 
                //                                   displayName); 
            }
            else if(IsNAntTask(doc) || IsNAntParameter(doc) || IsNAntNestedElement(doc))
            {
                displayName = $"<{displayName}>";
                // Wyam.Common.Tracing.Trace.Information("[GetNantRefDisplayName({0})] is not a NAntElement or a NAntFunction so displayName was set to {1}", 
                //                                   doc.String(CodeAnalysisKeys.QualifiedName), 
                //                                   displayName); 
            }
        }
    }

    return displayName;
};

/// <summary>
/// Returns the obsolete workaround message.
/// </summary>
DocumentConfig GetNantObsoleteMessage = (doc, ctx) =>
{
    string text = string.Empty;

    if(IsNAntObsolete(doc))
    {
        var attrDocs = doc.DocumentList(CodeAnalysisKeys.Attributes);
        if(attrDocs != null)
        {
            Microsoft.CodeAnalysis.AttributeData attrib = attrDocs.First(attr => IsNAntObsolete(attr))
                                                            .Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData);
                                
            text = attrib?.ConstructorArguments[0].Value.ToString();
        }
    }

    return text;
};

ContextConfig GetNAntRefLinks = (ctx) =>
{
    Dictionary<string, string> refLinks = new Dictionary<string, string>();
    foreach(IDocument doc in ctx.Documents["Reference"])
    {
        refLinks.Add(doc.String(CodeAnalysisKeys.QualifiedName), ctx.GetLink(doc));
    }

    //additional, external links
    refLinks.Add("al.exe", "https://docs.microsoft.com/en-us/dotnet/framework/tools/al-exe-assembly-linker");
    refLinks.Add("cl.exe", "https://docs.microsoft.com/en-us/cpp/build/reference/compiler-command-line-syntax?view=msvc-160");
    refLinks.Add("lib.exe", "https://docs.microsoft.com/en-us/cpp/build/reference/lib-reference?view=msvc-160");
    refLinks.Add("link.exe", "https://docs.microsoft.com/en-us/cpp/build/reference/linking?view=msvc-160");
    refLinks.Add("rc.exe", "https://docs.microsoft.com/en-us/windows/win32/menurc/using-rc-the-rc-command-line-");
    refLinks.Add("tlbexp.exe", "https://docs.microsoft.com/en-us/dotnet/framework/tools/tlbexp-exe-type-library-exporter");
    refLinks.Add("tlbimp.exe", "https://docs.microsoft.com/en-us/dotnet/framework/tools/tlbimp-exe-type-library-importer");
    refLinks.Add("touch ", "https://www.man7.org/linux/man-pages/man1/touch.1.html");

    return refLinks;
};



/**********************************************************************************************
 *                         NAnt pipelines
 **********************************************************************************************/
 /*
 * Disable API doc generation while in development
 */
if(noApi)
{
    Pipelines.Remove(Docs.RenderApi);
    Pipelines.Remove(Docs.ApiIndex);
    Pipelines.Remove(Docs.ApiSearchIndex);
}

/*
 * Disable blog posts while in development
 */
if(noBlog)
{
    Pipelines.Remove(Docs.BlogPosts);
    Pipelines.Remove(Docs.BlogIndexes);
    Pipelines.Remove(Docs.BlogCategories);
    Pipelines.Remove(Docs.BlogTags);
    Pipelines.Remove(Docs.BlogAuthors);
    Pipelines.Remove(Docs.BlogArchives);
    Pipelines.Remove(Docs.BlogYearlyArchives);
    Pipelines.Remove(Docs.BlogFeed);
    Pipelines.Remove(Docs.RenderBlogPosts);
}

/*
 * Disable pages while in development
 */
if(noPages)
{
    Pipelines.Remove(Docs.Pages);
    Pipelines.Remove(Docs.RenderPages);
    Pipelines.Remove(Docs.Redirects);
}
else
{
/*
 * Add NAnt schema files to release folder
 */
    Pipelines[Docs.Pages].InsertBefore(
        "CreateTreeAndSort",
        new IModule[]{
            new Concat{
                new ReadFiles("release/**/nant.xsd"),
                new Title("XML Schema"),
                new Meta(DocsKeys.ShowInSidebar, true).ForEachDocument()
            }
        }
    );
}

/*
 * Add NAnt reference documentation
 */
Pipelines.InsertAfter(Docs.Api, "Reference",
    Documents(Docs.Api),
    Where(IsNAntRef(@doc) || IsNAntElement(doc) || IsNAntEnum(doc)),
    Meta(NAntKeys.NAntAssembly, @doc.Get<IDocument>("ContainingAssembly").String("Name")),
    Meta(NAntKeys.NAntNamespace, @doc.Get<IDocument>("ContainingNamespace").String("Name")),
    Meta(NAntKeys.NAntRefType, GetNantRefType),
    Meta(NAntKeys.NAntTitle, GetNantRefTitle),
    Meta(NAntKeys.NAntDisplayName, GetNantRefDisplayName),
    Meta(NAntKeys.NAntObsolete, GetNantObsoleteMessage),
    Meta(DocsKeys.Title, @doc.String(NAntKeys.NAntTitle)),
    //Meta(CodeAnalysisKeys.DisplayName, @doc.String(NAntKeys.NAntDisplayName)),
    Meta(DocsKeys.Category, @doc.String(NAntKeys.NAntRefType)),
    Meta(DocsKeys.Tags, (doc, ctx) => { return IsNAntFunction(doc) ? new string[]{GetNAntFunctionSet(doc).Category} : new string[]{};}),
    Meta(Keys.WritePath, new FilePath($"reference/{@doc.String(NAntKeys.NAntRefType).ToLower()}/{@doc.String(NAntKeys.NAntTitle)}.html")),
    Meta(Keys.RelativeFilePath, @doc.FilePath(Keys.WritePath)),
    Trace($"[Reference pipe] {@doc.String(CodeAnalysisKeys.DisplayName)}-{@doc.String(CodeAnalysisKeys.Name)}-{@doc.String(NAntKeys.NAntRefType)}")
);
/*
 Pipelines.InsertAfter("Reference", "Test",
    Documents("Reference"),
    ForEach(
        Trace(DocToJson)
    )
 );
*/
Pipelines.InsertAfter("Reference", "ReferenceTypes",
    GroupBy(NAntKeys.NAntRefType, Documents("Reference")),
    Trace($"[ReferenceTypes pipe] {@doc.String(Keys.GroupKey)}"),
    Where(@doc.String(Keys.GroupKey) == (NAntRefType.Tasks).ToString()
            || @doc.String(Keys.GroupKey) == (NAntRefType.Filters).ToString()
            || @doc.String(Keys.GroupKey) == (NAntRefType.Functions).ToString()
            || @doc.String(Keys.GroupKey) == (NAntRefType.Types).ToString()),
    Meta(Keys.WritePath, new FilePath($"reference/{@doc.String(Keys.GroupKey).ToLower()}/index.html")),
    Meta(Keys.RelativeFilePath, @doc.FilePath(Keys.WritePath)),
    Merge(
        ReadFiles($"_reference/{@doc.String(Keys.GroupKey).ToLower()}/index.md"),
        new FrontMatter(new Yaml()),
        new Markdown(),
        Meta("TmpTitle", @doc.String(Keys.Title))
    ).ForEachDocument(),
    Meta(Keys.Title, @doc.String("TmpTitle"))
);

Pipelines.InsertAfter(Docs.Pages, "RenderReference",
    If(
        ctx => ctx.Documents["Reference"].Any(),
        Documents("Reference"),
        Where(@doc.Get<NAntRefType>(NAntKeys.NAntRefType) != NAntRefType.None),
        Razor().WithLayout("/_ReferenceLayout.cshtml"),
        Headings(),
        HtmlInsert("div#infobar-headings", (doc, ctx) => ctx.GenerateInfobarHeadings(doc)),
        WriteFiles()
    ).WithoutUnmatchedDocuments()
);

Pipelines.InsertAfter("RenderReference", "ReferenceIndex",
    Documents("ReferenceTypes"),
    Razor()
        .WithLayout("/_ReferenceIndex.cshtml"),
    AutoLink(GetNAntRefLinks).WithQuerySelector("code").WithMatchOnlyWholeWord(),
    WriteFiles()
);