// Preprocessor directives
//#n Wyam.Yaml
//#n Wyam.Razor
//#n Wyam.Markdown
//#n Wyam.Html
//#n Wyam.CodeAnalysis

#a **/*
/*
 * Hack to have intellisense in VS Code when debugging from IDE.
*/

#n System.Xml.ReaderWriter
#n System.Xml.XDocument

#recipe Docs

// Body code
// Normalize the culture for the examples so they produce the same output regardless of system culture
System.Globalization.CultureInfo.DefaultThreadCurrentCulture
    = System.Globalization.CultureInfo.CreateSpecificCulture("en-US");

ContentStreamFactory = new MemoryContentStreamFactory();

if(!Settings.ContainsKey(NAntKeys.Release))
{
    Settings[NAntKeys.Release] = "latest";
}

if(!Settings.ContainsKey(Keys.Host))
{
    Settings[Keys.Host] = string.Empty;
}
if(!Settings.ContainsKey(Keys.LinksUseHttps))
{
    Settings[Keys.LinksUseHttps] = false;
}
Settings[Keys.LinkRoot] = "/";
Settings[DocsKeys.Title] = "NAnt2";
Settings[DocsKeys.Logo] = "/assets/img/logo-dark.png";
//Settings[DocsKeys.ProjectFiles] = "../../src/**/{!.vscode,!bin,!obj,!packages,!*.Tests, !NDoc.*.NAnt,}/**/*.csproj";//
Settings[DocsKeys.ProjectFiles] = "../../src/{NAnt.Core,NAnt.DotNet}/*.csproj";
Settings[DocsKeys.IncludeDateInPostPath] = true;
Settings[DocsKeys.BlogAtomPath] = "blog/feed/atom/index.xml";
Settings[DocsKeys.BlogRssPath] = "blog/feed/rss/index.xml";
Settings[DocsKeys.BlogRdfPath] = null;
Settings[DocsKeys.CaseInsensitiveAuthors] = "true";
Settings[DocsKeys.CaseInsensitiveCategories] = "true";
Settings[DocsKeys.CaseInsensitiveTags] = "true";
Settings[DocsKeys.IgnoreFolders] = "_reference, App_Code";
Settings[DocsKeys.ImplicitInheritDoc] = true;

/// <value>When true pipelines Docs.RenderApi, Docs.ApiIndex and Docs.ApiSearchIndex are not executed.</value>
bool noApi = true;
/// <value>
/// When true pipelines Docs.BlogPosts, Docs.BlogIndexes, Docs.BlogCategories, Docs.BlogTags, Docs.BlogAuthors, 
/// Docs.BlogArchives, Docs.BlogYearlyArchives, Docs.BlogFeed, Docs.RenderBlogPosts are not executed.
/// </value>
bool noBlog = false;
/// <value>When true pipelines Docs.Pages, Docs.RenderPages, Docs.Redirects are not executed.</value>
bool noPages = false;

/**********************************************************************************************
 *                         NAnt customizations
 **********************************************************************************************/
 /// <summary>
 /// Meta-keys specific for NAnt.
 /// </summary>
 public static class NAntKeys
{
     /// <summary>
    /// The release version (short version, like latest or v0.95) to generate reference documentation.
    /// </summary>
    public const string Release = nameof(Release);

    /// <summary>
    /// the full version of the code used to generate documentation.
    /// </summary>
    public const string FullVersion = nameof(FullVersion);

    /// <summary>
    /// The assembly where the reference is located.
    /// </summary>
    public const string NAntAssembly = nameof(NAntAssembly);

    /// <summary>
    /// The namespace where the reference is located.
    /// </summary>
    public const string NAntNamespace = nameof(NAntNamespace);

    /// <summary>
    /// The page title for the NAnt reference.
    /// </summary>
    public const string NAntTitle = nameof(NAntTitle);

    /// <summary>
    /// The display name for the NAnt reference.
    /// </summary>
    public const string NAntDisplayName = nameof(NAntDisplayName);

    /// <summary>
    /// The reference type: task, function, type, filter, function set.
    /// </summary>
    public const string NAntRefType = nameof(NAntRefType);

    /// <summary>
    /// The NAnt reference is obsolete.
    /// </summary>
    public const string NAntObsolete = nameof(NAntObsolete);

    /// <summary>
    /// The resolution message for the obsolete NAnt reference.
    /// </summary>
    public const string NAntObsoleteMessage = nameof(NAntObsoleteMessage);
};

/// <summary>
/// NAnt reference types (task, type, function, filter, function set, parameters, nested elements, other elements and public enums).
/// </summary>
public enum NAntRefType{
    None,
    Tasks,
    Types,
    Functions,
    Filters,
    FunctionSets,
    Parameters,
    NestedElements,
    Elements,
    Enums
};

public class SlimMeta
{
    public string Title { get; set; }
    public string Category{ get; set; }
    public string Tags { get; set; }

    //Code
    public string SourceString { get; set; }
    public string Id { get; set; }
    public string Accessibility { get; set; }
    public string CommentId { get; set; }
    public string CommentXml { get; set; }
    public object ConstantValue { get; set; }
    public string DisplayName { get; set; }
    public string Example { get; set; }
    public string FullName { get; set; }
    public bool HasConstantValue { get; set; }
    public bool IsAbstract { get; set; }
    public bool IsOverride { get; set; }
    public bool IsResult { get; set; }
    public bool IsStatic { get; set; }
    public bool IsVirtual { get; set; }
    public string Kind { get; set; }
    public string Name { get; set; }
    public string QualifiedName { get; set; }
    public string RelativeFilePath { get; set; }
    public string RelativeFilePathBase { get; set; }
    public string Remarks { get; set; }
    public string Returns { get; set; }
    public string SpecificKind { get; set; }
    public string Summary { get; set; }
    //public object Symbol { get; set; }
    public string SymbolId { get; set; }
    public string Syntax { get; set; }
    public string Value { get; set; }
    public string WritePath { get; set; }

    //NAnt metadata
    public string NAntAssembly{ get; set; }
    public string NAntNamespace{ get; set; }
    public string NAntTitle{ get; set; }
    public string NAntDisplayName{ get; set; }
    public NAntRefType NAntRefType{ get; set; }
    public string NAntObsolete{ get; set; }
    public string NAntObsoleteMessage{ get; set; }

    protected SlimMeta(){ }

    public SlimMeta(IDocument meta)
    {
        if(meta == null) return;

        Title = meta.Get<string>(DocsKeys.Title);
        Category = meta.Get<string>(DocsKeys.Category);
        Tags = string.Join(", ", meta.Get<List<string>>(DocsKeys.Tags)?? new List<string>());

        //Code 
        SourceString = meta.SourceString(); 
        Id = meta.Id;
        Accessibility = meta.Get<string>(CodeAnalysisKeys.Accessibility);
        CommentId = meta.Get<string>(CodeAnalysisKeys.CommentId);
        CommentXml = meta.Get<string>(CodeAnalysisKeys.CommentXml);
        ConstantValue = meta.Get(CodeAnalysisKeys.ConstantValue);
        DisplayName = meta.Get<string>(CodeAnalysisKeys.DisplayName);
        Example = meta.Get<string>(CodeAnalysisKeys.Example);
        FullName = meta.Get<string>(CodeAnalysisKeys.FullName);
        HasConstantValue = meta.Get<bool>(CodeAnalysisKeys.HasConstantValue);
        IsAbstract = meta.Get<bool>(CodeAnalysisKeys.IsAbstract);
        IsOverride = meta.Get<bool>(CodeAnalysisKeys.IsOverride);
        IsResult = meta.Get<bool>(CodeAnalysisKeys.IsResult);
        IsStatic = meta.Get<bool>(CodeAnalysisKeys.IsStatic);
        IsVirtual = meta.Get<bool>(CodeAnalysisKeys.IsVirtual);
        Kind = meta.Get<string>(CodeAnalysisKeys.Kind);
        Name = meta.Get<string>(CodeAnalysisKeys.Name);
        QualifiedName = meta.Get<string>(CodeAnalysisKeys.QualifiedName);
        RelativeFilePath = meta.Get<string>(Keys.RelativeFilePath);
        RelativeFilePathBase = meta.Get<string>(Keys.RelativeFilePathBase);
        Remarks = meta.Get<string>(CodeAnalysisKeys.Remarks);
        Returns = meta.Get<string>(CodeAnalysisKeys.Returns);
        SpecificKind = meta.Get<string>(CodeAnalysisKeys.SpecificKind);
        Summary = meta.Get<string>(CodeAnalysisKeys.Summary);
        //Symbol = meta.Get(CodeAnalysisKeys.Symbol);
        SymbolId = meta.Get<string>(CodeAnalysisKeys.SymbolId);
        Syntax = meta.Get<string>(CodeAnalysisKeys.Syntax);
        Value = meta.Get<string>(CodeAnalysisKeys.Value);
        WritePath = meta.Get<string>(Keys.WritePath);

        //NAnt metadata
        NAntAssembly = meta.Get<string>(NAntKeys.NAntAssembly);
        NAntNamespace = meta.Get<string>(NAntKeys.NAntNamespace);
        NAntTitle = meta.Get<string>(NAntKeys.NAntTitle);
        NAntDisplayName = meta.Get<string>(NAntKeys.NAntDisplayName);
        NAntRefType = meta.Get<NAntRefType>(NAntKeys.NAntRefType);
        NAntObsolete = meta.Get<string>(NAntKeys.NAntObsolete);
        NAntObsoleteMessage = meta.Get<string>(NAntKeys.NAntObsoleteMessage);
    }
};
public class SlimDoc : SlimMeta
{
    public List<SlimMeta> AllInterfaces { get; set; }
    public string AttributeData { get; set; }
    public List<SlimMeta> Attributes { get; set; }
    public List<SlimMeta> BaseTypes { get; set; }
    public List<SlimMeta> Constructors { get; set; }
    public SlimMeta ContainingAssembly { get; set; }
    public SlimMeta ContainingNamespace { get; set; }
    public SlimMeta ContainingType { get; set; }
    public SlimMeta DeclaringType { get; set; }
    public List<SlimMeta> DerivedTypes { get; set; }
    public List<SlimMeta> ImplementingTypes { get; set; }
    public List<SlimMeta> MemberNamespaces { get; set; }
    public List<SlimMeta> Members { get; set; }
    public List<SlimMeta> MemberTypes { get; set; }
    public List<SlimMeta> Operators { get; set; }
    public SlimMeta OverriddenMethod { get; set; }
    public List<SlimMeta> Parameters { get; set; }

    protected SlimDoc(){ }

    public SlimDoc(IDocument iDoc)
        : base(iDoc)
    {
        if(iDoc == null) return;

        AllInterfaces = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.AllInterfaces)?.Select(x => new SlimMeta(x)).ToList();
        AttributeData = AttrToString(iDoc.Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData));
        Attributes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Attributes)?.Select(x => new SlimMeta(x)).ToList();
        BaseTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.BaseTypes)?.Select(x => new SlimMeta(x)).ToList();
        Constructors = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Constructors)?.Select(x => new SlimMeta(x)).ToList();
        ContainingAssembly = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.ContainingAssembly));
        ContainingNamespace = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace));
        ContainingType = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.ContainingType));
        DeclaringType = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.DeclaringType));
        DerivedTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.DerivedTypes)?.Select(x => new SlimMeta(x)).ToList();
        ImplementingTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.ImplementingTypes)?.Select(x => new SlimMeta(x)).ToList();
        MemberNamespaces = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.MemberNamespaces)?.Select(x => new SlimMeta(x)).ToList();
        Members = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Members)?.Select(x => new SlimMeta(x)).ToList();
        MemberTypes = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.MemberTypes)?.Select(x => new SlimMeta(x)).ToList();
        Operators = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Operators)?.Select(x => new SlimMeta(x)).ToList();
        OverriddenMethod = new SlimMeta(iDoc.Get<IDocument>(CodeAnalysisKeys.OverriddenMethod));
        Parameters = iDoc.Get<IReadOnlyList<IDocument>>(CodeAnalysisKeys.Parameters)?.Select(x => new SlimMeta(x)).ToList();
    }

    private string AttrToString(Microsoft.CodeAnalysis.AttributeData attributeData)
    {
        if(attributeData == null) return string.Empty;

        string result = string.Format("[{0}({1})]",
                                      attributeData.AttributeClass?.Name,
                                      attributeData.ConstructorArguments == null
                                        ? string.Empty
                                        : string.Join(",", attributeData.ConstructorArguments.Select(x => x.Value.ToString()))
                        );
        return result;

    }
};

/// <summary>
/// Embeds all NAnt-related logic to be also accesible in Razor views.
/// </summary>
public static class NAntUtils{
    public static DocumentConfig DocToJson = (doc, ctx) => {
        Newtonsoft.Json.Serialization.DefaultContractResolver contractResolver = new Newtonsoft.Json.Serialization.DefaultContractResolver
        {
            NamingStrategy = new Newtonsoft.Json.Serialization.CamelCaseNamingStrategy
            {
                ProcessDictionaryKeys = false
            }
        };
        var settings = new Newtonsoft.Json.JsonSerializerSettings()
        { 
            ContractResolver = contractResolver,
            Formatting = Newtonsoft.Json.Formatting.Indented,
            PreserveReferencesHandling = Newtonsoft.Json.PreserveReferencesHandling.All,
            ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore

        };

        SlimDoc slimDoc = new SlimDoc(doc);
        string json = Newtonsoft.Json.JsonConvert.SerializeObject(slimDoc, settings);

        return json;
    };

    /// <summary>
    /// If attribute is called <i>TaskNameAttribute</i> then it's a NAnt task attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntTaskAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "TaskNameAttribute";
    /// <summary>
    /// If attribute is called <i>FunctionAttribute</i> then it's a NAnt function attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntFunctionAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "FunctionAttribute";
    /// <summary>
    /// If attribute is called <i>FunctionSetAttribute</i> then it's a NAnt function set attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntFunctionSetAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "FunctionSetAttribute";
    /// <summary>
    /// If attribute is called <i>ElementNameAttribute</i> it's a NAnt filter or type attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntFilterOrTypeAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "ElementNameAttribute";
    /// <summary>
    /// If attribute is called <i>TaskAttributeAttribute</i> then it's a NAnt task parameter attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntParameterAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "TaskAttributeAttribute";
    /// <summary>
    /// If attribute is called <i>BuildElementAttribute</i> then it's a NAnt nested element attribute whose Type has Element attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntNestedSingleElementAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "BuildElementAttribute";
    /// <summary>
    /// If attribute is called <i>BuildElementArrayAttribute</i> or <i>BuildElementArrayAttribute</i> then it's a NAnt nested collection element attribute
    /// containing one or more build elements.
    /// </summary>
    public static Func<IDocument, bool> IsNAntNestedCollectionElementAttribute = (attr) => 
        attr.String(CodeAnalysisKeys.Name) == "BuildElementArrayAttribute" || attr.String(CodeAnalysisKeys.Name) == "BuildElementCollectionAttribute";
    /// <summary>
    /// If attribute is called <i>BuildElementAttribute</i>, <i>BuildElementArrayAttribute</i> or <i>BuildElementCollectionAttribute</i> 
    /// then it's a NAnt task nested element attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntNestedElementAttribute = (attr) => 
    {
        return IsNAntNestedSingleElementAttribute(attr) || IsNAntNestedCollectionElementAttribute(attr);
    };
    /// <summary>
    /// If attribute is called <i>Obsolete</i>.
    /// </summary>
    public static Func<IDocument, bool> IsNAntObsoleteAttribute = (attr) => attr.String(CodeAnalysisKeys.Name) == "ObsoleteAttribute";

    /// <summary>
    /// Returns true if the attribute is a NAnt task, function, filter, type, function set, parameter or nested element attribute.
    /// </summary>
    public static Func<IDocument, bool> IsNAntRefAttribute = (attr) => IsNAntTaskAttribute(attr) || IsNAntFilterOrTypeAttribute(attr) 
                                                                || IsNAntFunctionAttribute(attr) || IsNAntFunctionSetAttribute(attr) 
                                                                || IsNAntParameterAttribute(attr) || IsNAntNestedElementAttribute(attr);


    /// <summary>
    /// If document has an attribute called <i>TaskNameAttribute</i> then it's a NAnt task.
    /// </summary>
    public static Func<IDocument, bool> IsNAntTask = 
        (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class" 
                    && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                    && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntTaskAttribute(attr));
    /// <summary>
    /// If document has an attribute called <i>FunctionAttribute</i> then it's a NAnt function.
    /// </summary>
    public static Func<IDocument, bool> IsNAntFunction = 
        (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Method"
                    && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public" 
                    && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFunctionAttribute(attr));
    /// <summary>
    /// If document has an attribute called <i>FunctionSetAttribute</i> then it's a NAnt function set.
    /// </summary>
    public static Func<IDocument, bool> IsNAntFunctionSet = 
        (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class" 
                    && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                    && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFunctionSetAttribute(attr));
    /// <summary>
    /// If document has an attribute called <i>ElementNameAttribute</i> and derives from <i>Filter</i> then it's a NAnt filter.
    /// </summary>
    public static Func<IDocument, bool> IsNAntFilter = (doc) => 
    {
        return doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class"
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFilterOrTypeAttribute(attr))
                && doc.DocumentList(CodeAnalysisKeys.BaseTypes) != null
                && doc.DocumentList(CodeAnalysisKeys.BaseTypes).Any(bt => bt.String(CodeAnalysisKeys.Name) == "Filter");
    };
    /// <summary>
    /// If document has an attribute called <i>ElementNameAttribute</i> and is not derived from <i>Filter</i> then it's a NAnt type.
    /// </summary>
    public static Func<IDocument, bool> IsNAntType = (doc) => 
    {
        return doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class"
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntFilterOrTypeAttribute(attr))
                && (doc.DocumentList(CodeAnalysisKeys.BaseTypes) == null
                        || doc.DocumentList(CodeAnalysisKeys.BaseTypes).All(bt => bt.String(CodeAnalysisKeys.Name) != "Filter"));
    };
    /// <summary>
    /// If document has an attribute called <i>TaskAttributeAttribute</i> then it's a NAnt task parameter.
    /// </summary>
    public static Func<IDocument, bool> IsNAntParameter = 
        (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Property" 
                    && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                    && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntParameterAttribute(attr));
    /// <summary>
    /// If document has an attribute called <i>BuildElementAttribute</i>then it's a NAnt single nested element.
    /// </summary>
    public static Func<IDocument, bool> IsNAntNestedSingleElement =
        (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Property" 
                    && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                    && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntNestedSingleElementAttribute(attr));
     /// <summary>
    /// If document has an attribute called <i>BuildElementArrayAttribute</i> or <i>BuildElementCollectionAttribute</i> then it's a NAnt nested collection element.
    /// </summary>
    public static Func<IDocument, bool> IsNAntNestedCollectionElement =
        (doc) => doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Property" 
                    && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                    && doc.DocumentList(CodeAnalysisKeys.Attributes) != null
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntNestedCollectionElementAttribute(attr));
    /// <summary>
    /// If document has an attribute called <i>BuildElementAttribute</i>, <i>BuildElementArrayAttribute</i> or <i>BuildElementCollectionAttribute</i> 
    /// then it's a NAnt task nested element.
    /// </summary>
    public static Func<IDocument, bool> IsNAntNestedElement = (doc) => IsNAntNestedCollectionElement(doc) || IsNAntNestedSingleElement(doc);
    /// <summary>
    /// If document derives from <i>Element</i> then it's a NAnt element. 
    /// </summary>
    /// <returns></returns>
    public static Func<IDocument, bool> IsNAntElement = (doc) =>
    {
        bool isPublic = doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public";
        bool isClass = doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Class";
        bool derivesFromElement = doc.DocumentList(CodeAnalysisKeys.BaseTypes) != null
                                    && doc.DocumentList(CodeAnalysisKeys.BaseTypes).Any(bt => bt.String(CodeAnalysisKeys.QualifiedName) == "NAnt.Core.Element");
        bool notRef = doc.DocumentList(CodeAnalysisKeys.Attributes) == null 
                        || doc.DocumentList(CodeAnalysisKeys.Attributes).All(attr => !IsNAntRefAttribute(attr));

        // Wyam.Common.Tracing.Trace.Information(
        //     "[IsNAntElement({0})] returned {1} because it is a class: {4} derived from Element: {2} and does not have a NAnt ref attribute: {3}", 
        //     doc.String(CodeAnalysisKeys.QualifiedName),
        //     isClass && derivesFromElement && notRef,
        //     derivesFromElement,
        //     notRef,
        //     isClass);
        //Wyam.Common.Tracing.Trace.Verbose(DocToJson(doc, null).ToString());
        
        return isPublic && isClass && derivesFromElement && notRef;
    };

    /// <summary>
    /// If document derives from <i>System.Enum</i> and it's public then it's a NAnt enum.
    /// </summary>
    /// <returns></returns>
    public static Func<IDocument, bool> IsNAntEnum = (doc) =>
    {
        return doc.Get<string>(CodeAnalysisKeys.SpecificKind) == "Enum"
                && doc.Get<string>(CodeAnalysisKeys.Accessibility) == "Public"
                && doc.DocumentList(CodeAnalysisKeys.BaseTypes) != null
                && doc.DocumentList(CodeAnalysisKeys.BaseTypes).Any(bt => bt.String(CodeAnalysisKeys.QualifiedName) == "System.Enum")
                && doc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace).Get<string>(CodeAnalysisKeys.Name) != "Attributes"
                && doc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace).Get<string>(CodeAnalysisKeys.Name) != "Util";
    };

    /// <summary>
    /// If document has an attribute called <i>Obsolete</i>.
    /// </summary>
    /// <returns></returns>
    public static Func<IDocument, bool> IsNAntObsolete = 
        (doc) => doc.DocumentList(CodeAnalysisKeys.Attributes) != null 
                    && doc.DocumentList(CodeAnalysisKeys.Attributes).Any(attr => IsNAntObsoleteAttribute(attr));

    /// <summary>
    /// Returns true if the given <see cref="IDocument"/> is a NAnt task, function, filter or type.
    /// </summary>
    public static Func<IDocument, bool> IsNAntRef = (doc) => IsNAntTask(doc) || IsNAntType(doc) || IsNAntFunction(doc) || IsNAntFilter(doc);

    /// <summary>
    /// Extracts the first 2 atrribute parameters from the given document using the attribute selection function to select attributes.
    /// </summary>
    public static Func<IDocument, Func<IDocument, bool>, Tuple<object, object>> GetAttributeDetails = 
        (doc, atributeSelection) =>
    {
        object item1 = null;
        object item2 = null;

        if (doc == null || atributeSelection == null)
        {
            return Tuple.Create(item1, item2);
        }

        var attrDoc = doc.DocumentList(CodeAnalysisKeys.Attributes)
                        ?.FirstOrDefault(a => atributeSelection(a));
        if(attrDoc != null)
        {
            Microsoft.CodeAnalysis.AttributeData attrib = attrDoc.Get<Microsoft.CodeAnalysis.AttributeData>(CodeAnalysisKeys.AttributeData);
            if(attrib != null)
            {
                if(attrib.ConstructorArguments.Length >= 1) item1 = attrib.ConstructorArguments[0].Value;
                if(attrib.ConstructorArguments.Length >= 2) item2 = attrib.ConstructorArguments[1].Value;
            }
        }

        return Tuple.Create(item1, item2);
    };

    public static DocumentConfig GetNAntRefType = (doc, ctx) =>
    {
        NAntRefType nantType = NAntRefType.None;

        if(IsNAntTask(doc))
        {
            nantType = NAntRefType.Tasks;
        }
        else if(IsNAntFilter(doc))
        {
            nantType = NAntRefType.Filters;
        }
        else if(IsNAntType(doc))
        {
            nantType = NAntRefType.Types;
        }
        else if(IsNAntFunction(doc))
        {
            nantType = NAntRefType.Functions;
        }
        else if(IsNAntFunctionSet(doc))
        {
            nantType = NAntRefType.FunctionSets;
        }
        else if(IsNAntParameter(doc))
        {
            nantType = NAntRefType.Parameters;
        }
        else if(IsNAntNestedElement(doc))
        {
            nantType = NAntRefType.NestedElements;
        }
        else if(IsNAntElement(doc))
        {
            nantType = NAntRefType.Elements;
        }
        else if(IsNAntEnum(doc))
        {
            nantType = NAntRefType.Enums;
        }

        // Wyam.Common.Tracing.Trace.Verbose("[GetNantRefType({0})] {0} is a NAntRefType.{1}", 
        //                                 doc.String(CodeAnalysisKeys.QualifiedName), 
        //                                 nantType);
        return nantType;
    };

    public static DocumentConfig GetNAntRefTitle = (doc, ctx) =>
    {
        string title = string.Empty;

        if(IsNAntElement(doc) || IsNAntEnum(doc))
        {
            title = doc.String(CodeAnalysisKeys.QualifiedName);
        }
        else if(IsNAntRef(doc)|| IsNAntFunctionSet(doc) || IsNAntParameter(doc) || IsNAntNestedElement(doc))
        {
            Tuple<object, object> details = GetAttributeDetails(doc, IsNAntRefAttribute);
            title = Convert.ToString(details.Item1) ?? string.Empty;

            if(IsNAntFunction(doc))
            {
                Tuple<object, object> fsDetails = GetAttributeDetails(doc.Get<IDocument>(CodeAnalysisKeys.ContainingType), IsNAntFunctionSetAttribute);
                title = $"{Convert.ToString(fsDetails.Item1) ?? string.Empty}.{title}"; // function-set_prefix.function_title
            }
        }

        return title;
    };

    public static DocumentConfig GetNAntRefDisplayName = (doc, ctx) =>
    {
        string displayName = string.Empty;

        if(IsNAntElement(doc) || IsNAntEnum(doc))
        {
            displayName = doc.String(CodeAnalysisKeys.DisplayName);
        }
        else if(IsNAntRef(doc)|| IsNAntFunctionSet(doc) || IsNAntParameter(doc) || IsNAntNestedElement(doc))
        {
            Tuple<object, object> details = GetAttributeDetails(doc, IsNAntRefAttribute);
            displayName = Convert.ToString(details.Item1) ?? string.Empty;
            
            if(IsNAntFunction(doc))
            {
                Tuple<object, object> fsDetails = GetAttributeDetails(doc.Get<IDocument>(CodeAnalysisKeys.ContainingType), IsNAntFunctionSetAttribute);
                displayName = $"{Convert.ToString(fsDetails.Item1) ?? string.Empty}::{displayName}"; // function-set_prefix::function_title
            }
            else if(IsNAntTask(doc) || IsNAntParameter(doc) || IsNAntNestedElement(doc))
            {
                displayName = $"<{displayName}>"; 
            }
        }

        return displayName;
    };

    /// <summary>
    /// Returns the obsolete workaround message.
    /// </summary>
    public static DocumentConfig GetNAntObsoleteMessage = (doc, ctx) =>
    {
        string text = string.Empty;

        if(IsNAntObsolete(doc))
        {
            Tuple<object, object> details = GetAttributeDetails(doc, IsNAntObsoleteAttribute);
            text = Convert.ToString(details.Item1) ?? string.Empty;
        }

        return text;
    };

    /// <summary>
    /// Returns document tags based on document reference type. For functions it will return the function set Category.
    /// </summary>
    public static DocumentConfig GetNAntTags = (doc, ctx)=> {
        List<string> tags = new List<string>();

        if(IsNAntFunction(doc))
        {
            Tuple<object, object> fsDetails = GetAttributeDetails(doc.Get<IDocument>(CodeAnalysisKeys.ContainingType), IsNAntFunctionSetAttribute);
            if(fsDetails.Item2 != null)
            {
                tags.Add(Convert.ToString(fsDetails.Item2));
            }
        }

        return tags;
    };

    /// <summary>
    ///  Returns the proper WritePath.
    /// </summary>
    public static DocumentConfig GetNAntWritePath = (doc, ctx) =>
    {
        FilePath writePath;

        //if doc namespace starts with NAnt then it's either in api or reference folder
        //else it's a standard .NET reference and link it to https://docs.microsoft.com/en-us/dotnet/api/?term=<doc.QualifiedName>
        IDocument  nDoc = doc.Get<IDocument>(CodeAnalysisKeys.ContainingNamespace);
        if(nDoc == null || nDoc.String(CodeAnalysisKeys.QualifiedName).StartsWith("NAnt"))
        {
            if(IsNAntRef(doc) || IsNAntElement(doc) || IsNAntEnum(doc))
            {
                writePath =  new FilePath($"reference/{doc.String(NAntKeys.NAntRefType).ToLower()}/{doc.String(NAntKeys.NAntTitle)}.html");
            }
            else
            {
                writePath = doc.Get<FilePath>(Keys.WritePath);
            }
        }
        else
        {
            writePath = new FilePath("https://docs.microsoft.com/en-us/dotnet/api/?term=" 
                                        + System.Net.WebUtility.UrlEncode(doc.String(CodeAnalysisKeys.QualifiedName)));
        }

        return writePath;
    };

    public static ContextConfig GetNAntRefLinks = (ctx) =>
    {
        Dictionary<string, string> refLinks = new Dictionary<string, string>();
        foreach(IDocument doc in ctx.Documents["Reference"])
        {
            string docName = doc.String(NAntKeys.NAntDisplayName);
            if(!refLinks.ContainsKey(docName))
            {
                refLinks.Add(docName, ctx.GetLink(doc));
            }
            
            docName = doc.String(CodeAnalysisKeys.QualifiedName);
            if(!refLinks.ContainsKey(docName))
            {
                refLinks.Add(docName, ctx.GetLink(doc));
            }
            else
            {
                //Wyam.Common.Tracing.Trace.Verbose($"[NAntUtils.GetNAntRefLinks] Document {docName} already in url list with path {refLinks[docName]}. Cannot add {ctx.GetLink(doc)}");
            }
        }

        //additional, external links
        refLinks.Add("al.exe", "https://docs.microsoft.com/en-us/dotnet/framework/tools/al-exe-assembly-linker");
        refLinks.Add("cl.exe", "https://docs.microsoft.com/en-us/cpp/build/reference/compiler-command-line-syntax?view=msvc-160");
        refLinks.Add("lib.exe", "https://docs.microsoft.com/en-us/cpp/build/reference/lib-reference?view=msvc-160");
        refLinks.Add("link.exe", "https://docs.microsoft.com/en-us/cpp/build/reference/linking?view=msvc-160");
        refLinks.Add("rc.exe", "https://docs.microsoft.com/en-us/windows/win32/menurc/using-rc-the-rc-command-line-");
        refLinks.Add("tlbexp.exe", "https://docs.microsoft.com/en-us/dotnet/framework/tools/tlbexp-exe-type-library-exporter");
        refLinks.Add("tlbimp.exe", "https://docs.microsoft.com/en-us/dotnet/framework/tools/tlbimp-exe-type-library-importer");
        refLinks.Add("touch ", "https://www.man7.org/linux/man-pages/man1/touch.1.html");

        return refLinks;
    };

    /// <summary>
    /// Returns the document with the same sourceString and id from Resources pipelines because the list of documents forming the current document methods and properties do not contain the NAnt metadata.
    /// </summary>
    /// <returns></returns>
    public static DocumentConfig GetNAntReferenceDoc = (doc, ctx) =>
    {
        if(doc == null) return null;

        IDocument refDoc = ctx.Documents["Reference"]
                              .First( r => r.Get<NAntRefType>(NAntKeys.NAntRefType) != NAntRefType.None
                                        && r.Id == doc.Id 
                                        && r.String(CodeAnalysisKeys.SymbolId) == doc.String(CodeAnalysisKeys.SymbolId));
        return refDoc;
    };
};



/**********************************************************************************************
 *                         NAnt pipelines
 **********************************************************************************************/
 /*
 * Disable API doc generation while in development
 */
if(noApi)
{
    Pipelines.Remove(Docs.RenderApi);
    Pipelines.Remove(Docs.ApiIndex);
    Pipelines.Remove(Docs.ApiSearchIndex);
}

/*
 * Disable blog posts while in development
 */
if(noBlog)
{
    Pipelines.Remove(Docs.BlogPosts);
    Pipelines.Remove(Docs.BlogIndexes);
    Pipelines.Remove(Docs.BlogCategories);
    Pipelines.Remove(Docs.BlogTags);
    Pipelines.Remove(Docs.BlogAuthors);
    Pipelines.Remove(Docs.BlogArchives);
    Pipelines.Remove(Docs.BlogYearlyArchives);
    Pipelines.Remove(Docs.BlogFeed);
    Pipelines.Remove(Docs.RenderBlogPosts);
}

/*
 * Disable pages while in development
 */
if(noPages)
{
    Pipelines.Remove(Docs.Pages);
    Pipelines.Remove(Docs.RenderPages);
    Pipelines.Remove(Docs.Redirects);
}
else
{
/*
 * Add NAnt schema files to release folder
 */
    Pipelines[Docs.Pages].InsertBefore(
        "CreateTreeAndSort",
        new IModule[]{
            new Concat{
                new ReadFiles("release/**/nant.xsd"),
                new Title("XML Schema"),
                new Meta(DocsKeys.ShowInSidebar, true).ForEachDocument()
            }
        }
    );
}

/*
 * Add NAnt reference documentation
 */
Pipelines.InsertAfter(Docs.Api, "Reference",
    Documents(Docs.Api),
    Meta(NAntKeys.NAntAssembly, @doc.Get<IDocument>("ContainingAssembly")?.String("Name")),
    Meta(NAntKeys.NAntNamespace, @doc.Get<IDocument>("ContainingNamespace")?.String("Name")),
    //Trace("[Reference pipe] After NAntNamespace"),
    Meta(NAntKeys.NAntRefType, NAntUtils.GetNAntRefType),
    //Trace("[Reference pipe] After NAntRefType"),
    Meta(NAntKeys.NAntTitle, NAntUtils.GetNAntRefTitle),
    //Trace("[Reference pipe] After NAntTitle"),
    Meta(NAntKeys.NAntDisplayName, NAntUtils.GetNAntRefDisplayName),
    //Trace("[Reference pipe] After NAntDisplayName"),
    Meta(NAntKeys.NAntObsolete, (doc, ctx) => NAntUtils.IsNAntObsolete(doc)),
    //Trace("[Reference pipe] After NAntObsolete"),
    Meta(NAntKeys.NAntObsoleteMessage, NAntUtils.GetNAntObsoleteMessage),
    //Trace("[Reference pipe] After NAntObsoleteMessage"),
    Meta(DocsKeys.Title, @doc.String(NAntKeys.NAntTitle)),
    //Trace("[Reference pipe] After Title"),
    //Meta(CodeAnalysisKeys.DisplayName, @doc.String(NAntKeys.NAntDisplayName)),
    Meta(DocsKeys.Category, @doc.String(NAntKeys.NAntRefType)),
    //Trace("[Reference pipe] After Category"),
    Meta(DocsKeys.Tags, NAntUtils.GetNAntTags),
    //Trace("[Reference pipe] After Tags"),
    Meta(Keys.WritePath, NAntUtils.GetNAntWritePath),
    //Trace("[Reference pipe] After WritePath"),
    Meta(Keys.RelativeFilePath, @doc.FilePath(Keys.WritePath))
    //Trace($"[Reference pipe] {@doc.String(CodeAnalysisKeys.DisplayName)}-{@doc.String(CodeAnalysisKeys.Name)}-{@doc.String(NAntKeys.NAntRefType)}")
);

/*
 Pipelines.InsertAfter("Reference", "Test",
    Documents(Docs.Api),
    ForEach(
        Trace(DocToJson)
    )
 );
*/

Pipelines.InsertAfter("Reference", "ReferenceTypes",
    GroupBy(NAntKeys.NAntRefType, Documents("Reference")),
    Trace($"[ReferenceTypes pipe] {@doc.String(Keys.GroupKey)}"),
    Where(@doc.String(Keys.GroupKey) == (NAntRefType.Tasks).ToString()
            || @doc.String(Keys.GroupKey) == (NAntRefType.Filters).ToString()
            || @doc.String(Keys.GroupKey) == (NAntRefType.Functions).ToString()
            || @doc.String(Keys.GroupKey) == (NAntRefType.Types).ToString()),
    Meta(Keys.WritePath, new FilePath($"reference/{@doc.String(Keys.GroupKey).ToLower()}/index.html")),
    Meta(Keys.RelativeFilePath, @doc.FilePath(Keys.WritePath)),
    Merge(
        ReadFiles($"_reference/{@doc.String(Keys.GroupKey).ToLower()}/index.md"),
        new FrontMatter(new Yaml()),
        new Markdown(),
        Meta("TmpTitle", @doc.String(Keys.Title))
    ).ForEachDocument(),
    Meta(Keys.Title, @doc.String("TmpTitle"))
);

Pipelines.InsertAfter(Docs.Pages, "RenderReference",
    Documents("Reference"),
    Where(NAntUtils.IsNAntRef(@doc) || NAntUtils.IsNAntElement(doc) || NAntUtils.IsNAntEnum(doc)),
    Razor().WithLayout("/_ReferenceLayout.cshtml"),
    Headings(),
    HtmlInsert("div#infobar-headings", (doc, ctx) => ctx.GenerateInfobarHeadings(doc)),
    WriteFiles()
);

Pipelines.InsertAfter("RenderReference", "ReferenceIndex",
    Documents("ReferenceTypes"),
    Razor()
        .WithLayout("/_ReferenceIndex.cshtml"),
    AutoLink(NAntUtils.GetNAntRefLinks).WithQuerySelector("code").WithMatchOnlyWholeWord(),
    WriteFiles()
);