@using Microsoft.AspNetCore.Html
@using Microsoft.AspNetCore.Mvc.ModelBinding
@using System
@using Wyam.Common.Tracing

@model IDocument
@{
    Trace.Information($"[_RefNestedElements {ViewData["root"]}] recursive calling with level {ViewData["level"]} - Model is {Model.SourceString()}");

    int level = ViewData.ContainsKey("level") ? Convert.ToInt32(ViewData["level"]) : 1;
    string root = ViewData.ContainsKey("root") ? Convert.ToString(ViewData["root"]) : string.Empty;
    if(level == 1)
    {
        ViewData["root"] = Model.SourceString();
        root = Model.SourceString();
    } 

    @*The same document as Model but retrieved from References pipelines, containing the NAnt meta information*@
    IDocument refModel = (IDocument)NAntUtils.GetNAntReferenceDoc(Model, Context);
    if(refModel == null) 
    {
        Trace.Information($"[_RefNestedElements {root}] Reference model not found for {Model.SourceString()}");
    };

    bool hasNestedElements = Model.List<IDocument>("Members") != null
                                && Model.List<IDocument>("Members").Any(x => NAntUtils.IsNAntNestedElement(x)); 
    

    Func<IDocument, (string Name, string ChildName, Type ChildType)> GetNestedElementDetails = (propDoc) =>{
		if(NAntUtils.IsNAntNestedElement(propDoc))
		{
			Dictionary<string, object> details = NAntUtils.GetAttributeDetails(propDoc, NAntUtils.IsNAntNestedElementAttribute);
            if(details != null)
            {
                string nameKey = details.ContainsKey("name") ? "name" : "collectionName";
                return (Name: details.ContainsKey(nameKey) ? Convert.ToString(details[nameKey]) : string.Empty, 
                        ChildName: details.ContainsKey("childName") ? Convert.ToString(details["childName"]) : string.Empty,
                        ChildType: details.ContainsKey("elementType") ? (Type)details["ElementType"] : null);
            }
		}
		
        return (Name: string.Empty, ChildName: string.Empty, ChildType: null);
	};
}

@if(hasNestedElements)
{
    var heading = level == 1 ? "h1" : "h3";
    var headingId = level == 1 ? "NestedElements" : Model.String("Name") + "NestedElements";
    var divClass = "container-fluid";

    @Html.Raw($@"<{heading} id=""{headingId}"">Nested elements</{heading}>");
    <div class="@divClass">
        @{
            IList<IDocument> nestedElements =  Model.List<IDocument>("Members")
                                            .Where(x => NAntUtils.IsNAntNestedElement(x))
                                            .OrderBy(x => x["DisplayName"])
                                            .ToList();
            Trace.Information($"[_RefParameters {root}] Found {(nestedElements == null ? 0 : nestedElements.Count)} nested elements for {Model.SourceString()}");
        }
        @foreach(IDocument nElemDoc in nestedElements)
        {
            var newViewData = new ViewDataDictionary(this.ViewData);
            newViewData["level"] = level + 1;
            Trace.Information($"[_RefNestedElements {root}] recursive calling with level {newViewData["level"]} for document {nElemDoc.SourceString()}");
            Html.RenderPartial("Section\\_RefNestedElements", nElemDoc, newViewData);
        }
    </div>
}
@if(NAntUtils.IsNAntNestedSingleElement(Model))
{
    @*The document for Model type: the one contained in Model and the one retrieved from References pipelines, containing the NAnt meta information *@
    IDocument type = Model.Get<IDocument>("Type");
    IDocument refType = (IDocument)NAntUtils.GetNAntReferenceDoc(type, Context);

    @* Trace.Information($"[_RefNestedElements {root}] level {ViewData["level"]}. Document '{Model.SourceString()}' is nested single element and it's ref doc is {NAntUtils.DocToJson(type, Context)}"); *@
    Trace.Information($"[_RefNestedElements {root}] level {ViewData["level"]}. Document '{Model.SourceString()}' is nested single element and type is {refType.String(NAntKeys.NAntDisplayName)}");

    var linkName = GetNestedElementDetails(Model).Name;
    var link = type == null ? string.Empty : Context.GetLink(refType.FilePath(Keys.WritePath));
    var obsolete = NAntUtils.GetObsoleteDetails(refModel);

    <div class="row">
        <h2>
            <a href="@link">&lt;@(linkName)&gt;</a>
            @if(obsolete.Obsolete)
            {
                <i class="fa fa-exclamation-triangle text-warning" aria-hidden="true"></i>
            }
        </h2>
        <div class="col-xs-@(13-level) col-xs-offset-@(level-1) col-sm-@(13-level) col-sm-offset-@(level-1) col-md-@(13-level) col-md-offset-@(level-1) col-lg-@(13-level) col-lg-offset-@(level-1)">
            <p>@Html.Raw(Model.Get("Summary"))</p>
            <!-- put the nested element class docs inline if the element does not derive from DataTypeBase (meaning, is not a global type) 
                    - instead of checking base classes, we'll check if it has a link to NAnt reference types
            -->
            @if(string.IsNullOrEmpty(link))
            {
                <p>@Html.Raw(type.Get("Summary"))</p>
                <p>@Html.Raw(type.String("Remarks"))</p>
                if(obsolete.Obsolete)
                {
                    <div class="alert alert-warning">
                        <i>Obsolete. @Html.Raw(obsolete.Details)</i>
                    </div>
                }
                {
                    var newViewData = new ViewDataDictionary(this.ViewData);
                    Trace.Information($"[_RefNestedElements {root}] _RefParameters calling with level {newViewData["level"]} for document {refModel.SourceString()}");
                    Html.RenderPartial("Section\\_RefParameters", refType, newViewData);
                    Html.RenderPartial("Section\\_RefNestedElements", refType, newViewData);
                }
            }
        </div>
        <h2><a href="@link">&lt;/@(linkName)&gt;</a></h2>
    </div>
}
@if(NAntUtils.IsNAntNestedCollectionElement(Model) || NAntUtils.IsNAntNestedArrayElement(Model))
{
    var collectionElement = GetNestedElementDetails(Model);
    var obsolete = NAntUtils.GetObsoleteDetails(refModel);

     Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: collection is {collectionElement.Name};{collectionElement.ChildName};{collectionElement.ChildType}"); 

    <div class="row">
        <h2>
            &lt;@(collectionElement.Name)&gt;
             @if(obsolete.Obsolete)
            {
                <i class="fa fa-exclamation-triangle text-warning" aria-hidden="true"></i>
            }
        </h2>
        <div class="col-xs-@(13-level) col-xs-offset-@(level-1) col-sm-@(13-level) col-sm-offset-@(level-1) col-md-@(13-level) col-md-offset-@(level-1) col-lg-@(13-level) col-lg-offset-@(level-1)">
            
            <p>@Html.Raw(Model.Get("Summary"))</p>
            @if(obsolete.Obsolete)
            {
                <div class="alert alert-warning">
                    <i>Obsolete. @Html.Raw(obsolete.Details)</i>
                </div>
            }
            
            @{
                IDocument child;
                //find IDocument that corresponds the child Type, if specified
                if(collectionElement.ChildType != null)
                {
                    child = Context.Documents["Reference"]
                              .First( r => r.Get<NAntRefType>(NAntKeys.NAntRefType) != NAntRefType.None
                                            && r.Get<IDocument>(CodeAnalysisKeys.Type).String(CodeAnalysisKeys.QualifiedName) == collectionElement.ChildType.ToString());
                    Trace.Information($"[_RefNestedElements {root}] found child {child} for provided child type {collectionElement.ChildType}");
                }
                //if childType not provided find IDocument that corresponds to Type returned by the Add method of the collection
                else
                {
                    Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: type is {Model.Get<IDocument>("Type").String(CodeAnalysisKeys.QualifiedName)}");
                    //Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: type is {NAntUtils.DocToJson(Model.Get<IDocument>("Type"), Context)}");

                    //for arrays, kind is "ArrayType", e.g. SourceString = "NAnt.Core.Types.Token[]"
                    //for collections, kind is "NamedType", e.g. SourceString = "NAnt.Core.Types.ArgumentCollection"
                    string typeKind = Model.Get<IDocument>("Type").String(CodeAnalysisKeys.Kind);
                    //Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: typeKind is {typeKind}");
                    string childName = string.Empty;
                    if( typeKind == "NamedType")
                    {
                        childName = Model.Get<IDocument>("Type")
                                            .List<IDocument>("Members")
                                            ?.FirstOrDefault(x => x.String(CodeAnalysisKeys.Name) == "Add")
                                            ?.SourceString(); //e.g. "NAnt.Core.Types.ArgumentCollection.Add(NAnt.Core.Types.Argument)"
                        //Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: typeKind is {typeKind}, raw childName is {childName}");
                        childName = childName.Substring(childName.LastIndexOf("(") +1, 
                                                    childName.LastIndexOf(")") - childName.LastIndexOf("(") -1);
                        Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: typeKind is {typeKind}, childName is {childName}");
                    }
                    else if( typeKind == "ArrayType")
                    {
                        childName = Model.Get<IDocument>("Type")
                                        .SourceString(); //"NAnt.Core.Types.Token[]"
                        //Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: typeKind is {typeKind}, raw childName is {childName}");
                        childName = childName.Substring(0, childName.LastIndexOf("["));
                        Trace.Information($"[_RefNestedElements {root}] At level {level} for document {Model.SourceString()}: typeKind is {typeKind}, childName is {childName}");
                    }

                    child = Context.Documents["Reference"]
                              .FirstOrDefault( r => r.Get<NAntRefType>(NAntKeys.NAntRefType) != NAntRefType.None
                                                        && r.String(CodeAnalysisKeys.QualifiedName) == childName);
                    Trace.Information($"[_RefNestedElements {root}] found child {child} for based on Add method");
                }
                
                //Trace.Information("[_RefNestedElements view] found child " + NAntUtils.DocToJson(child, Context));
                if(child != null)
                {
                    var newViewData = new ViewDataDictionary(this.ViewData);

                    <p>@Html.Raw(child.String("Remarks"))</p>
                    Html.RenderPartial("Section\\_RefParameters", child, newViewData);
                    
                    Trace.Information($"[_RefNestedElements {root}] recursive calling with level {newViewData["level"]} for child {child.SourceString()}");
                    Html.RenderPartial("Section\\_RefNestedElements", child, newViewData);

                    @Html.Partial("Section\\_Examples", child, newViewData)
                }
                else
                {
                    <p>No child element found</p>
                }
            }

        </div>
        <h2>&lt;@(collectionElement.Name)&gt;</h2>
    </div>
} 